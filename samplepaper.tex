% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}
\usepackage{hyperref}

\begin{document}
%
\title{Music streaming and song recommendations using ML algorithms}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Anthony M. Schomer}
%
\authorrunning{A. Schomer.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Northwest Missouri State University, Maryville MO 64468, USA \\
\email{tony.schomer@gmail.com}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
This capstone project investigates the algorithms used by music streaming services to recommend similar songs to enhance user experiences. The focus is on how platforms like Spotify and Apple Music use listeners preferences including Likes, dislikes, and other relevant information to create personalized playlists tailored to individual tastes. This project uses open datasets such as Spotify Million Playlist Dataset, Spotify Web API, and Musicbrain.org's extensive library of databases. Using smart computer programs to create a test system that suggests songs based on user behavior and preferences. It looks at how current song recommendations systems work. Machine learning methods. such as, collaborative filtering and content-based analysis to build test recommendation systems. This project also will address challenges within the current algorithms to help avoid common issues. One significant issue to avoid is users hearing the same song over and over again. These findings will help improve the music discovery online and suggest ways to innovate and enhance recommendations for listeners and introduce them to new artists. 

\keywords{music \and streaming \and recommendations \and data \and user experience}
\end{abstract}

% ... [Previous sections remain unchanged] ...

\section{Machine Learning Component}

Based on our EDA, we developed a content-based recommendation system using cosine similarity. This approach leverages the audio features and genre information to suggest similar tracks.

\subsection{Feature Engineering}

We combined numerical audio features with one-hot encoded genre features to create a comprehensive feature vector for each track.

\begin{verbatim}
features = df[['danceability', 'energy', 'loudness', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo']]
features = pd.concat([features, df.filter(regex='^genre_')], axis=1)
\end{verbatim}

\subsection{Similarity Computation}

We used cosine similarity to compute the similarity between tracks:

\begin{verbatim}
from sklearn.metrics.pairwise import cosine_similarity

similarity_matrix = cosine_similarity(features)
\end{verbatim}

\subsection{Recommendation Function}

We created a function to recommend similar tracks based on a given input track:

\begin{verbatim}
def get_recommendations(track_id, top_n=5):
    idx = df.index[df['track_id'] == track_id].tolist()[0]
    sim_scores = list(enumerate(similarity_matrix[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:top_n+1]
    track_indices = [i[0] for i in sim_scores]
    return df.iloc[track_indices]

# Example usage
recommended_tracks = get_recommendations('spotify:track:1234567890', top_n=5)
print(recommended_tracks[['track_name', 'artist_name']])
\end{verbatim}

\section{Findings and Conclusions}

Based on our analysis and the implementation of the recommendation system, we have drawn the following conclusions:

\begin{enumerate}
    \item Audio features play a crucial role in determining song similarity, with energy and loudness being particularly influential.
    \item Genre information enhances the recommendation quality, especially for niche genres.
    \item The content-based approach provides consistent recommendations but may lack serendipity in discovering entirely new styles of music.
    \item Popular genres like Pop and Rock dominate the dataset, which may lead to bias in recommendations towards these genres.
    \item The correlation between danceability and valence suggests that positive, upbeat songs are often more danceable, which could be leveraged for mood-based playlists.
\end{enumerate}

Future work could involve:
\begin{itemize}
    \item Incorporating collaborative filtering to balance content-based recommendations with user preferences.
    \item Exploring time-based features to capture evolving music trends.
    \item Implementing diversity measures to ensure a mix of familiar and novel recommendations.
\end{itemize}

This analysis provides a foundation for understanding music recommendation systems and highlights the complex interplay of factors that influence listener preferences and streaming platform algorithms.

\section{Full Project Code}

Below is the complete code used for this project, including data extraction, processing, analysis, and the recommendation system implementation:

\begin{verbatim}
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics.pairwise import cosine_similarity

# Spotify API Authentication
client_credentials_manager = SpotifyClientCredentials(client_id='your_client_id', client_secret='your_client_secret')
sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)

# Load dataset
df = pd.read_csv('spotify_million_playlist.csv')

# Remove duplicates
df.drop_duplicates(subset='track_id', inplace=True)

# Handle missing values
df['tempo'].fillna(df['tempo'].median(), inplace=True)
df.dropna(subset=['genre'], inplace=True)

# Normalize numerical features
scaler = StandardScaler()
numerical_features = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo']
df[numerical_features] = scaler.fit_transform(df[numerical_features])

# One-hot encode 'genre'
df = pd.get_dummies(df, columns=['genre'])

# Function to fetch additional track details from Spotify API
def get_track_details(track_id):
    try:
        track = sp.track(track_id)
        return {
            'popularity': track['popularity'],
            'release_date': track['album']['release_date']
        }
    except:
        return {'popularity': np.nan, 'release_date': np.nan}

# Apply the function to get additional details (limited to first 1000 tracks for demonstration)
additional_details = df['track_id'].head(1000).apply(get_track_details)
additional_df = pd.DataFrame(additional_details.tolist())
df = pd.concat([df.head(1000), additional_df], axis=1)

# EDA: Distribution of Audio Features
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
sns.histplot(df['danceability'], kde=True, ax=axes[0, 0])
sns.histplot(df['energy'], kde=True, ax=axes[0, 1])
sns.histplot(df['valence'], kde=True, ax=axes[1, 0])
sns.histplot(df['tempo'], kde=True, ax=axes[1, 1])
plt.tight_layout()
plt.savefig('audio_features_distribution.png')

# EDA: Correlation Analysis
corr = df[numerical_features].corr()
plt.figure(figsize=(10, 8))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.savefig('correlation_heatmap.png')

# Feature Engineering for Recommendation System
features = df[numerical_features]
features = pd.concat([features, df.filter(regex='^genre_')], axis=1)

# Compute Similarity Matrix
similarity_matrix = cosine_similarity(features)

# Recommendation Function
def get_recommendations(track_id, top_n=5):
    idx = df.index[df['track_id'] == track_id].tolist()[0]
    sim_scores = list(enumerate(similarity_matrix[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:top_n+1]
    track_indices = [i[0] for i in sim_scores]
    return df.iloc[track_indices]

# Example usage
recommended_tracks = get_recommendations('spotify:track:1234567890', top_n=5)
print(recommended_tracks[['track_name', 'artist_name']])
\end{verbatim}

This code encompasses the entire workflow of the project, from data loading and preprocessing to exploratory data analysis and the implementation of the recommendation system.

\section{Additional Resources}
The following resources were utilized and referenced throughout this project:

\begin{itemize}
    \item \href{https://www.kaggle.com/datasets/shubhendra/million-playlist-dataset}{Kaggle: Spotify Million Playlist Dataset}
    \item \href{https://developer.spotify.com/documentation/web-api/}{Spotify Web API Documentation}
    \item \href{https://musicbrainz.org/}{MusicBrainz Database}
    \item \href{https://www.acm.org/publications/policies/duplicate-publication}{ACM: Duplicate Publication Policy}
    \item \href{https://www.overleaf.com/project}{Overleaf Project}
    \item \textbf{GitHub Repository:} \href{https://github.com/anythonyschomer/Capstone-Project-Report}{Capstone Project Report}
\end{itemize}

% Any additional dashed information or notes can go here
\vspace{-1em} % Space before additional notes
\rule{\textwidth}{0.4pt} % Horizontal line for separation
\vspace{-0.5em} % Space before additional notes
This project was conducted by Anthony M. Schomer at Northwest Missouri State University.

\end{document}